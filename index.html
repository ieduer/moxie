<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- 禁用縮放 -->
    <title>墨力全開 - AI 默寫教練</title>
    <style>
        /* 基本樣式保持不變 */
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; background-color: #f9f9f9; }
        h1 { text-align: center; color: #333; }
        strong { color: #d9534f; }
        #status, #questions, #result { margin-top: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 8px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .question-item { margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px dashed #eee; }
        .question-item:last-child { border-bottom: none; }
        pre { background-color: #f4f4f4; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; }
        button { padding: 12px 20px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; font-size: 1em; transition: background-color 0.2s ease; margin-left: 5px; }
        button:hover:not(:disabled) { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .button-group { display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;}
        h2 { margin-top: 0; color: #0056b3; }
        .underline-blank { text-decoration: underline; color: #aaa; display: inline-block; min-width: 10em; text-align: center;}
        .answer-wrapper { margin-top: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #fff; }
        .canvas-container { position: relative; width: 100%; height: 180px; /* 稍微增加高度 */ border-bottom: 1px solid #eee;}
        /* Canvas 本身不再需要背景色，繪圖會覆蓋 */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 4px 4px 0 0;
            touch-action: none; /* 必須保留 */
            cursor: crosshair; /* 改成十字光標 */
        }
        .controls { padding: 5px; text-align: right; }
        .clear-btn { background-color: #f0ad4e; font-size: 0.9em; padding: 5px 10px;}
        .clear-btn:hover { background-color: #ec971f; }
        .loading { font-style: italic; color: #555; }
        .result-item { margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; }
        .result-item p { margin: 5px 0; }
    </style>
    <!-- 引入 perfect-freehand 庫 -->
    <script src="https://cdn.jsdelivr.net/npm/perfect-freehand@1.2.0/dist/perfect-freehand.min.js"></script>
</head>
<body>
    <h1>墨力全開 - AI 默寫教練</h1>
    <p style="text-align: center;"><strong>目標：高考默寫 8 分，必須拿滿！一分都不能少！</strong></p>
    <p style="text-align: center; color: orange; font-weight: bold;">
        請務必使用工整、清晰的標準簡體字書寫，筆畫分明，避免潦草、連筆或過於藝術化的字體，否則 AI 可能無法正確識別！
    </p>

    <div class="button-group">
        <button id="get-question-btn">開始挑戰</button>
        <button id="check-backend-btn">檢查後端狀態</button>
    </div>

    <div id="status">狀態：等待操作...</div>
    <div id="questions" style="display: none;">
        <h2>請默寫以下內容 (共 8 分):</h2>
        <div id="question-list"></div>
        <button id="submit-btn" style="margin-top: 20px; width: 100%;" disabled>提交答案</button>
    </div>
    <div id="result" style="display: none;"></div>

    <script>
        // --- 全局變量和常量 ---
        const statusDiv = document.getElementById('status');
        const questionsDiv = document.getElementById('questions');
        const questionListDiv = document.getElementById('question-list');
        const resultDiv = document.getElementById('result');
        const getQuestionBtn = document.getElementById('get-question-btn');
        const checkBackendBtn = document.getElementById('check-backend-btn');
        const submitBtn = document.getElementById('submit-btn');

        let currentQuestions = [];
        let canvasInstances = []; // 存儲每個 canvas 的狀態和數據

        // perfect-freehand 繪圖選項
        const drawOptions = {
            size: 3,        // 筆觸基礎大小
            thinning: 0.6,  // 線條隨速度變細的程度 (0-1)
            smoothing: 0.5, // 線條平滑度 (0-1)
            streamline: 0.5,// 流線型程度 (0-1)
            color: 'black'
        };

        // --- 工具函數 ---
        function setLoadingState(button, isLoading, defaultText) { /* ... (代碼不變) ... */ }

        // 將 SVG 路徑數據繪製到 Canvas
        function drawPressureStroke(ctx, stroke) {
            if (!stroke.length) return;
            ctx.beginPath();
            const [x, y] = stroke[0];
            ctx.moveTo(x, y);
            stroke.slice(1).forEach(([x, y]) => ctx.lineTo(x, y));
            ctx.stroke();
        }

        // 將 perfect-freehand 點數據轉換為 SVG 路徑
        function getSvgPathFromStroke(stroke) {
            if (!stroke.length) return ''

            const d = stroke.reduce(
                (acc, [x0, y0], i, arr) => {
                    const [x1, y1] = arr[(i + 1) % arr.length]
                    acc.push(`Q ${x0},${y0} ${(x0 + x1) / 2},${(y0 + y1) / 2}`)
                    return acc
                },
                ['M', ...stroke[0], 'Q', ...stroke[0]]
            )

            return `${d.join(' ')} Z`
        }


        function initializeCanvas(canvasElement, index) {
            const ctx = canvasElement.getContext('2d');
            let points = []; // 存儲當前筆畫的點 [x, y, pressure]
            let currentStroke = null; // 存儲 perfect-freehand 計算出的當前筆畫輪廓點
            let isDrawing = false;

            // 設置 Canvas 繪圖屬性
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.fillStyle = drawOptions.color; // 使用 fillStyle 因為我們要填充路徑

            // 清除 Canvas
            function clearCanvas() {
                const rect = canvasElement.getBoundingClientRect(); // 需要獲取尺寸來清除
                ctx.clearRect(0, 0, rect.width / (window.devicePixelRatio || 1), rect.height / (window.devicePixelRatio || 1)); // 清除時使用 CSS 像素單位
                canvasInstances[index].strokes = []; // 清空筆畫數據
                console.log(`Canvas ${canvasElement.id} cleared`);
            }

             // 添加筆畫數據到存儲
             function addStrokeToSavedStrokes() {
                 if (currentStroke) {
                      // 注意：我們應該保存原始的 points，而不是計算後的 stroke
                      // 因為 resize 時需要用原始 points 重新計算 stroke
                      // 但為了簡化，我們先保存計算後的 stroke，resize 時重繪它
                      // 更優方案是保存 points，並在 redraw 時重新計算所有 stroke
                     canvasInstances[index].strokes.push(currentStroke); // 保存計算後的輪廓點
                     currentStroke = null;
                 }
             }

            // 繪製單個筆畫 (使用填充)
            function drawStroke(strokeToDraw) {
                if (!strokeToDraw || strokeToDraw.length < 1) return;
                const pathData = perfectFreehand.getSvgPathFromStroke(strokeToDraw);
                const path = new Path2D(pathData);
                ctx.fill(path);
            }

            // 重新繪製所有已保存的筆畫和當前筆畫
            function redrawAllStrokes() {
                // 清除整個 Canvas (使用 CSS 像素單位計算清除範圍)
                const dpr = window.devicePixelRatio || 1;
                ctx.clearRect(0, 0, canvasElement.width / dpr, canvasElement.height / dpr);

                // 繪製所有已保存的筆畫
                canvasInstances[index].strokes.forEach(savedStroke => {
                    drawStroke(savedStroke);
                });
                // 繪製當前正在畫的筆畫
                drawStroke(currentStroke);
            }

            // --- **修改後的事件處理，使用 getBoundingClientRect** ---
            function getPoint(e) {
                const rect = canvasElement.getBoundingClientRect();
                // 對於觸摸事件，使用第一個觸點
                const touch = e.touches ? e.touches[0] : e;
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                // 如果 pressure 不可用，提供默認值 0.5
                const pressure = touch.pressure !== undefined ? touch.pressure : (e.pointerType === 'pen' ? e.pressure : 0.5);
                // console.log(x,y, pressure); // 調試坐標和壓力
                return [x, y, pressure];
            }

            function handlePointerDown(e) {
                // e.preventDefault(); // 阻止滾動等，如果 touch-action:none 不夠的話
                isDrawing = true;
                points = [getPoint(e)]; // 使用新函數獲取坐標
                currentStroke = null; // 開始新筆畫，清除舊的計算結果
                redrawAllStrokes(); // 繪製起始點
            }

            function handlePointerMove(e) {
                if (!isDrawing) return;
                // e.preventDefault();
                points.push(getPoint(e)); // 添加新點

                // 使用 perfect-freehand 計算平滑後的筆畫輪廓點
                currentStroke = perfectFreehand.getStroke(points, drawOptions);
                redrawAllStrokes(); // 重繪以顯示當前進度
            }

            function handlePointerUp(e) {
                // e.preventDefault();
                if (!isDrawing) return;
                isDrawing = false;
                 // points.push(getPoint(e)); // 可以選擇是否記錄抬筆點

                // 計算最終筆畫輪廓並保存
                 if (points.length > 0) {
                     currentStroke = perfectFreehand.getStroke(points, { ...drawOptions, last: true }); // 使用 last: true
                     addStrokeToSavedStrokes(); // 保存計算結果
                 } else {
                     currentStroke = null; // 如果沒有點，則沒有筆畫
                 }

                points = []; // 清空點記錄以備下次使用
                redrawAllStrokes(); // 繪製最終的完整筆畫
            }

            // 綁定事件 (Pointer 事件兼容鼠標和觸摸)
            canvasElement.addEventListener('pointerdown', handlePointerDown);
            canvasElement.addEventListener('pointermove', handlePointerMove);
            canvasElement.addEventListener('pointerup', handlePointerUp);
            canvasElement.addEventListener('pointerleave', handlePointerUp); // 離開畫布也算結束

            // 清除按鈕
            const clearButton = canvasElement.closest('.answer-wrapper').querySelector('.clear-btn');
            if (clearButton) {
                clearButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    clearCanvas();
                });
            }

            // 保存實例信息 (包括用於導出的方法)
            canvasInstances[index] = {
                canvas: canvasElement,
                ctx: ctx,
                strokes: [], // 存儲計算後的筆畫輪廓點 [[x,y], ...]
                clear: clearCanvas,
                isEmpty: () => canvasInstances[index].strokes.length === 0,
                toDataURL: (type = 'image/png') => {
                    // 重新繪製確保內容最新
                    redrawAllStrokes();
                    // 導出時可能需要創建一個新的 Canvas 來繪製白色背景
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvasElement.width;
                    tempCanvas.height = canvasElement.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    // 繪製白色背景
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    // 將當前內容繪製到臨時 Canvas 上
                    // 注意：需要反向縮放，因為 drawImage 使用的是圖像原始像素
                     const ratio = Math.max(window.devicePixelRatio || 1, 1);
                    tempCtx.drawImage(canvasElement, 0, 0, canvasElement.width / ratio, canvasElement.height / ratio);

                    return tempCanvas.toDataURL(type); // 從臨時 Canvas 導出
                }
            };

            // 初始調整大小
            resizeCanvas(canvasElement);
        }


        // --- **修改後的 resizeCanvas 函數，但繪圖邏輯移到 redraw** ---
        function resizeCanvas(canvas) {
            const ratio = Math.max(window.devicePixelRatio || 1, 1);
            canvas.width = canvas.offsetWidth * ratio;
            canvas.height = canvas.offsetHeight * ratio;
            const ctx = canvas.getContext("2d");
            ctx.scale(ratio, ratio); // 只需要設置縮放
            console.log(`Canvas resized: ${canvas.id}, Ratio: ${ratio}, Width: ${canvas.width}, Height: ${canvas.height}`);

             // 找到對應實例並觸發重繪
             const instance = canvasInstances.find(inst => inst.canvas === canvas);
             if (instance && instance.strokes) {
                 // 延遲一點執行重繪，確保尺寸生效
                 setTimeout(() => {
                     const redrawCtx = instance.ctx;
                     redrawCtx.clearRect(0, 0, canvas.width / ratio, canvas.height / ratio); // 清除舊內容
                     instance.strokes.forEach(stroke => {
                         const pathData = perfectFreehand.getSvgPathFromStroke(stroke);
                         const path = new Path2D(pathData);
                         redrawCtx.fillStyle = drawOptions.color;
                         redrawCtx.fill(path);
                     });
                     console.log(`Redrawn canvas ${canvas.id} after resize.`);
                 }, 50); // 短暫延遲
             }
        }

        // --- 獲取題目邏輯 ---
        getQuestionBtn.addEventListener('click', async () => {
             setLoadingState(getQuestionBtn, true, '開始挑戰');
             // ... (省略請求和錯誤處理) ...
             try {
                 const response = await fetch('/api/question');
                 // ... (檢查 response.ok) ...
                 const questions = await response.json();
                 if (questions && questions.length > 0) {
                     currentQuestions = questions;
                     statusDiv.textContent = '題目獲取成功！請作答。';
                     questionListDiv.innerHTML = ''; // 清空
                     canvasInstances = new Array(questions.length); // 重置實例數組

                     questions.forEach((q, index) => {
                         // ... (創建 item 和 HTML 結構) ...
                         const item = document.createElement('div');
                         item.classList.add('question-item');
                         const formattedQuestion = q.question.replace(/_+/g, '<span class="underline-blank"> </span>');
                         item.innerHTML = `
                             <p><strong>${index + 1}. (${q.topic || '2分'})</strong></p>
                             <p>${formattedQuestion}</p>
                             <div class="answer-wrapper">
                                 <div class="canvas-container">
                                     <canvas id="canvas-${q.id}"></canvas>
                                 </div>
                                 <div class="controls">
                                     <button class="clear-btn" type="button">清除</button>
                                 </div>
                             </div>
                         `;
                         questionListDiv.appendChild(item);
                         // --- **獲取剛剛添加的 canvas 並初始化** ---
                         const canvasElement = item.querySelector(`#canvas-${q.id}`);
                         if (canvasElement) {
                            initializeCanvas(canvasElement, index);
                         } else {
                             console.error(`Could not find canvas element for question ${q.id}`);
                         }
                     });
                     questionsDiv.style.display = 'block';
                     submitBtn.disabled = false;
                 } else { /* ... */ }
             } catch (error) { /* ... */ }
              finally { setLoadingState(getQuestionBtn, false, '開始挑戰'); }
        });

        // --- 檢查後端狀態邏輯 (不變) ---
        checkBackendBtn.addEventListener('click', async () => { /* ... */ });

        // --- **修改後的提交答案邏輯，使用新的 canvasInstances** ---
        submitBtn.addEventListener('click', async () => {
             setLoadingState(submitBtn, true, '提交答案');
             resultDiv.innerHTML = '<div class="loading">正在提交答案並等待 AI 評分...</div>';
             resultDiv.style.display = 'block';

             const answersData = [];
             canvasInstances.forEach((instance, index) => {
                 if (!currentQuestions || !currentQuestions[index]) return;
                 const questionId = currentQuestions[index].id;
                 if (instance.isEmpty()) {
                     answersData.push({ questionId: questionId, imageDataUrl: null });
                 } else {
                     // 使用實例提供的 toDataURL 方法
                     const dataUrl = instance.toDataURL('image/png');
                     answersData.push({ questionId: questionId, imageDataUrl: dataUrl });
                 }
             });

              if (answersData.length !== currentQuestions.length) { /* ... 錯誤處理 ... */ }

             try {
                 const response = await fetch('/api/submit', { /* ... (請求部分不變) ... */ });
                 // ... (錯誤處理) ...
                 const resultData = await response.json();
                 // ... (渲染結果邏輯不變) ...
                 let resultHTML = `<h2>評分結果 (總分: ${resultData.totalScore} / 8)</h2>`;
                 // ... (根據 resultData.results 渲染 HTML) ...
                 resultDiv.innerHTML = resultHTML;

             } catch (error) { /* ... (錯誤處理) ... */ }
              finally { setLoadingState(submitBtn, false, '提交答案'); }
        });

        // --- **窗口大小變化監聽器 (保持不變)** ---
        let resizeTimeout;
        window.addEventListener("resize", () => { /* ... (resize 邏輯不變) ... */ });

    </script>
</body>
</html>