<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>墨力全開 - AI 默寫教練 (拍照版 v2)</title>
    <style>
        /* Styles remain largely the same as provided before */
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; background-color: #f9f9f9; }
        h1 { text-align: center; color: #333; }
        strong { color: #d9534f; } /* Make strong elements red for emphasis */
        #status, #questions, #result, #upload-section { margin-top: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 8px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .question-item { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed #eee; }
        .question-item:last-child { border-bottom: none; }
        /* Updated question styling for context + verse */
        .question-context { display: block; margin-bottom: 5px; font-style: italic; color: #555; }
        .question-verse { font-weight: bold; margin-left: 5px; } /* Style for verse part */
        .question-source { font-size: 0.85em; color: #666; margin-left: 10px;} /* Style for source */
        pre { background-color: #f4f4f4; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; color: #333; border: 1px solid #ddd;}
        button { padding: 12px 20px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; font-size: 1em; transition: background-color 0.2s ease; margin: 5px; } /* Add margin */
        button:hover:not(:disabled) { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; }
        .button-group { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; justify-content: center; } /* Allow wrapping */
        h2 { margin-top: 0; color: #0056b3; border-bottom: 2px solid #eee; padding-bottom: 5px;}
        /* Underline style for blanks - improved visibility */
        .underline-blank {
            text-decoration: none; /* Remove default underline */
            border-bottom: 1.5px solid #888; /* Use border for better control */
            padding: 0 0.5em; /* Add some padding inside the blank */
            color: #888;
            display: inline-block;
            min-width: 8em; /* Adjust as needed */
            text-align: center;
            font-weight: normal; /* Ensure it doesn't inherit bold */
         }
        .loading { font-style: italic; color: #555; text-align: center; padding: 20px; font-size: 1.1em; }
        .result-item { margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; }
        .result-item p { margin: 8px 0; }
        .result-item strong { color: #333; } /* Keep title strong black */
        .result-item .label { font-weight: bold; color: #555; min-width: 70px; display: inline-block;}
        .recognized-text { font-weight: bold; padding: 2px 4px; border-radius: 3px; }
        .correct-answer-text { font-weight: bold; color: #1a7431; background-color: #e8f5e9; padding: 2px 4px; border-radius: 3px;}
        .incorrect-answer-text { color: #c62828; background-color: #ffebee; }
        .correct-tick { color: green; font-weight: bold; }
        .incorrect-cross { color: red; font-weight: bold; }
        .error-message { color: #d9534f; font-weight: bold; margin-top: 10px; }
         .feedback-box { margin-top: 25px; padding: 15px; border-radius: 5px; font-size: 1.1em; text-align: center; white-space: pre-wrap; /* Preserve line breaks from AI */ word-wrap: break-word; }
        .feedback-success { background-color: #dff0d8; border: 1px solid #d6e9c6; color: #3c763d; }
        .feedback-fail { background-color: #f2dede; border: 1px solid #ebccd1; color: #a94442; font-weight: bold;}
        /* Styles for file upload and preview */
        #upload-section { border-top: 2px solid #007bff; margin-top: 30px; }
        #image-upload-label { display: block; margin-bottom: 10px; font-weight: bold; }
        #image-upload { display: block; margin-bottom: 15px; font-size: 1em; cursor: pointer; }
        #image-preview-container { margin-top: 15px; text-align: center; }
        #image-preview { max-width: 90%; max-height: 400px; border: 1px solid #ddd; border-radius: 4px; display: none; margin: 10px auto; box-shadow: 0 0 5px rgba(0,0,0,0.1); }
        #compression-info { font-size: 0.9em; color: #666; margin-top: 10px; text-align: center; min-height: 1.2em; }
        #submit-btn { margin-top: 20px; width: calc(100% - 10px); /* Adjust width slightly */ } /* Make submit button full width */

        /* Style for processing hints */
        .processing-hints {
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ffeeba;
            background-color: #fff3cd;
            color: #856404;
            border-radius: 4px;
        }
        .processing-hints p {
            margin: 5px 0;
            font-weight: bold;
        }

    </style>
    <!-- **引入 browser-image-compression 庫** -->
    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>
</head>
<body>
    <h1>墨力全開 - AI 默寫教練 (拍照版 v2)</h1>
    <p style="text-align: center;"><strong>目標：高考默寫 8 分，必須拿滿！一分都不能少！</strong></p>
    <p style="text-align: center; color: orange; font-weight: bold;">
        請將 4 道題的答案按順序清晰寫在紙上，然後拍照上傳。確保光線充足、字跡清晰、答案豎直排列！
    </p>

    <div class="button-group">
        <button id="get-question-btn">開始挑戰</button>
        <button id="check-backend-btn">檢查後端狀態</button>
    </div>

    <div id="status">狀態：等待操作...</div>

    <div id="questions" style="display: none;">
        <h2>請在紙上書寫以下內容 (共 8 分):</h2>
        <div id="question-list"></div>
        <!-- 上傳區域移到題目列表之後 -->
    </div>

    <div id="upload-section" style="display: none;">
        <h2>拍照並上傳答案</h2>
        <label for="image-upload" id="image-upload-label">選擇或拍攝照片:</label>
        <input type="file" id="image-upload" name="image-upload" accept="image/*" capture="environment"> <!-- Added capture -->
        <div id="compression-info"></div>
        <div id="image-preview-container">
            <img id="image-preview" src="#" alt="圖片預覽">
        </div>
         <button id="submit-btn" disabled>提交答案照片</button>
    </div>

    <div id="result" style="display: none;"></div>

    <script>
        // --- DOM Elements ---
        const statusDiv = document.getElementById('status');
        const questionsDiv = document.getElementById('questions');
        const questionListDiv = document.getElementById('question-list');
        const uploadSection = document.getElementById('upload-section');
        const imageUploadInput = document.getElementById('image-upload');
        const imagePreview = document.getElementById('image-preview');
        const compressionInfo = document.getElementById('compression-info');
        const resultDiv = document.getElementById('result');
        const getQuestionBtn = document.getElementById('get-question-btn');
        const checkBackendBtn = document.getElementById('check-backend-btn');
        const submitBtn = document.getElementById('submit-btn');

        // --- State Variables ---
        let currentQuestions = [];
        let currentSetId = null; // Stores the current question set ID from backend
        let compressedImageBlob = null; // Stores the compressed image Blob object
        let isSubmitting = false; // Prevent double submission

        // --- Utility Functions ---
        function setLoadingState(button, isLoading, defaultText = '操作') {
             button.disabled = isLoading;
             button.textContent = isLoading ? '處理中...' : defaultText;
        }

        function resetUI() {
            statusDiv.textContent = '狀態：等待操作...';
            resultDiv.style.display = 'none';
            resultDiv.innerHTML = '';
            questionsDiv.style.display = 'none';
            uploadSection.style.display = 'none';
            questionListDiv.innerHTML = '';
            currentQuestions = [];
            currentSetId = null;
            compressedImageBlob = null;
            imagePreview.style.display = 'none';
            imagePreview.src = '#'; // Reset preview src
            imageUploadInput.value = ''; // Clear file selection
            compressionInfo.textContent = '';
            submitBtn.disabled = true;
            isSubmitting = false;
        }

        function displayError(message, container = statusDiv) {
             console.error("Error:", message);
             // Use innerHTML to allow simple HTML tags like <br> if needed
             container.innerHTML = `<p class="error-message">錯誤：${message}</p>`;
             container.style.display = 'block'; // Ensure error container is visible
        }

        // Function to safely escape HTML to prevent XSS
         function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') {
                 console.warn("escapeHtml called with non-string:", unsafe);
                 return String(unsafe); // Convert non-strings to strings
            }
            // Chain replace calls correctly
            return unsafe
                 .replace(/&/g, "&")
                 .replace(/</g, "<")
                 .replace(/>/g, ">")
                 // << FINAL CORRECTION: Use single quotes for the replacement string literal >>
                 .replace(/"/g, '"')
                 // << END FINAL CORRECTION >>
                 .replace(/'/g, "'"); // Ensure this line ends with a semicolon if it's the last in the chain for the return statement.
         }


        // --- Event Listeners ---

        // Start Challenge Button
        getQuestionBtn.addEventListener('click', async () => {
            resetUI(); // Reset everything before starting a new challenge
            setLoadingState(getQuestionBtn, true, '開始挑戰');
            statusDiv.textContent = '正在從後端獲取新題組...';

            try {
                // **Call the /api/start_set endpoint**
                const response = await fetch('/api/start_set');
                 // Check for non-OK HTTP status first
                 if (!response.ok) {
                     let errorMsg = `HTTP 錯誤！狀態: ${response.status} ${response.statusText}`;
                     try { // Try to parse potential JSON error from backend
                         const errorData = await response.json();
                         errorMsg = errorData.error || errorMsg; // Use backend error if available
                     } catch (e) { /* Ignore parsing error */ }
                     throw new Error(errorMsg); // Throw after checking response
                 }

                const setData = await response.json();

                if (setData && setData.setId && setData.questions && setData.questions.length > 0) {
                    currentSetId = setData.setId;
                    currentQuestions = setData.questions;

                    statusDiv.textContent = `獲取題組成功 (ID: ${currentSetId})！請在紙上作答後拍照上傳。`;
                    questionsDiv.style.display = 'block';
                    uploadSection.style.display = 'block'; // Show upload section only after getting questions

                    // Display questions
                    currentQuestions.forEach((q, index) => {
                        const item = document.createElement('div');
                        item.classList.add('question-item');
                        const questionString = q.question || "";
                        const parts = questionString.split('\n'); // Split context and verse
                        const context = parts[0] || "";
                        const versePart = parts.length > 1 ? parts[1] : ""; // Verse is the second part

                        // Format verse part with blank
                        const formattedVerse = escapeHtml(versePart).replace(/_{2,}/g, '<span class="underline-blank"> </span>'); // Use   for empty blanks

                        // Prepare source string beforehand (Robust fix from previous attempt)
                        const topicText = escapeHtml(q.topic || "2分");
                        const sourceText = escapeHtml(q.source || "未知");
                        const sourceInfoString = `(${topicText} | 來源: ${sourceText})`;

                        item.innerHTML = `
                            <p>
                                <strong>${index + 1}.</strong>
                                <span class="question-context">${escapeHtml(context)}</span>
                                <span class="question-verse">${formattedVerse}</span>
                                <span class="question-source">${sourceInfoString}</span> 
                             </p>`;
                        questionListDiv.appendChild(item);
                    });

                } else {
                    throw new Error('未能從後端獲取有效的題組數據。');
                }
            } catch (error) {
                displayError(`獲取題目失敗: ${error.message}`);
                resetUI(); // Reset UI fully on error
            } finally {
                setLoadingState(getQuestionBtn, false, '開始挑戰');
            }
        });

        // Image Selection and Compression
        imageUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            compressedImageBlob = null; // Reset blob
            submitBtn.disabled = true; // Disable submit until compression done
            imagePreview.style.display = 'none';
            compressionInfo.textContent = '';

            if (!file) return;

            if (!file.type.startsWith('image/')) {
                displayError('請選擇有效的圖片文件！', compressionInfo);
                imageUploadInput.value = ''; // Clear invalid selection
                return;
            }

            // Show Preview (before compression)
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
            }
            reader.readAsDataURL(file);

            // Compress Image
            compressionInfo.textContent = '正在壓縮圖片...';
            console.log(`原始圖片大小: ${(file.size / 1024 / 1024).toFixed(2)} MB`);

            const options = {
                maxSizeMB: 1,
                maxWidthOrHeight: 1920,
                useWebWorker: true,
                 // signal: abortController.signal // Add abort signal if needed
            };

            try {
                // **Use browser-image-compression**
                compressedImageBlob = await imageCompression(file, options);
                console.log(`壓縮後圖片大小: ${(compressedImageBlob.size / 1024 / 1024).toFixed(2)} MB`);
                compressionInfo.textContent = `圖片已準備就緒 (大小: ${(compressedImageBlob.size / 1024 / 1024).toFixed(2)} MB)`;
                submitBtn.disabled = false; // Enable submit button
            } catch (error) {
                console.error('圖片壓縮失敗:', error);
                displayError(`圖片壓縮失敗: ${error.message}`, compressionInfo);
                compressedImageBlob = null;
                imagePreview.style.display = 'none';
                 imageUploadInput.value = ''; // Clear selection on compression failure
            }
        });

        // Check Backend Status Button
        checkBackendBtn.addEventListener('click', async () => {
             setLoadingState(checkBackendBtn, true, '檢查後端狀態');
             statusDiv.textContent = '正在檢查後端狀態...';
             try {
                 const response = await fetch('/api/hello');
                 if (!response.ok) throw new Error(`HTTP ${response.status}`);
                 const data = await response.json();
                 statusDiv.innerHTML = `後端狀態：<pre>${escapeHtml(JSON.stringify(data, null, 2))}</pre>`;
             } catch (error) {
                 displayError(`無法連接後端或後端錯誤: ${error.message}`);
             } finally {
                 setLoadingState(checkBackendBtn, false, '檢查後端狀態');
             }
        });

        // Submit Answers Button
        submitBtn.addEventListener('click', async () => {
            if (isSubmitting) return; // Prevent double clicks
            if (!compressedImageBlob) {
                alert('請先選擇並等待圖片壓縮完成！');
                return;
            }
            if (!currentSetId) {
                 alert('缺少題組信息 (Set ID)，請先點擊 "開始挑戰" 獲取題目。');
                 return;
            }

            isSubmitting = true;
            setLoadingState(submitBtn, true, '提交答案照片');
            resultDiv.innerHTML = '<div class="loading">正在上傳圖片並等待 AI 評分，請稍候...</div>';
            resultDiv.style.display = 'block'; // Show loading message
             // Scroll to results
             resultDiv.scrollIntoView({ behavior: 'smooth' });


            const formData = new FormData();
            formData.append('setId', currentSetId);
            // Use a filename that might be useful for backend debugging
            formData.append('handwritingImage', compressedImageBlob, `set_${currentSetId}_answer.png`);

            try {
                const response = await fetch('/api/submit', {
                    method: 'POST',
                    body: formData,
                     // Let browser set Content-Type for FormData
                });

                 if (!response.ok) {
                     let errorMsg = `提交失敗！狀態: ${response.status} ${response.statusText}`;
                     try {
                         const errorData = await response.json();
                         errorMsg = errorData.error || errorMsg;
                     } catch (e) { /* Ignore parsing error */ }
                     throw new Error(errorMsg);
                 }

                const resultData = await response.json();

                // --- Render Results ---
                let resultHTML = `<h2>評分結果 (總分: ${resultData.totalScore ?? 'N/A'} / 8)</h2>`;

                 // Display Processing Hints (OCR/Feedback Issues)
                 let hintsHTML = '';
                 if (resultData.ocrIssue) {
                     hintsHTML += `<p>OCR 提示：${escapeHtml(resultData.ocrIssue)}</p>`;
                 }
                 // Only show the hints container if there are hints
                 if (hintsHTML) {
                    resultHTML += `<div class="processing-hints">${hintsHTML}</div>`;
                 }

                if (resultData.results && Array.isArray(resultData.results)) {
                    resultData.results.forEach((res, index) => {
                        const isCorrect = res.isCorrect;
                        const score = res.score !== undefined ? res.score : 'N/A';
                        const recognized = escapeHtml(res.recognizedText || '[未能識別]');
                        const correct = escapeHtml(res.correctAnswer || '[標準答案缺失]');
                        // Determine border color based on success/correctness
                        let borderColor = '#ccc'; // Default
                         if (res.success === false || recognized.startsWith('[') ) { // Simplified check for error placeholders
                             borderColor = '#aaa'; // Grey for processing errors/unrecognized
                         } else if (isCorrect) {
                             borderColor = '#5cb85c'; // Green for correct
                         } else {
                             borderColor = '#d9534f'; // Red for incorrect
                         }


                        resultHTML += `<div class="result-item" style="border-left: 5px solid ${borderColor};">`;
                        resultHTML += `<p><strong>第 ${index + 1} 題</strong> (得分: ${score}) ${isCorrect ? '<span class="correct-tick">✔</span>' : '<span class="incorrect-cross">✘</span>'}</p>`;

                         // Display recognized and correct answers clearly
                         resultHTML += `<p><span class="label">識別結果:</span> <span class="recognized-text ${!isCorrect && res.success ? 'incorrect-answer-text' : ''}">${recognized}</span></p>`;
                         // Only show correct answer if different or if there was an item-level error
                         if (!isCorrect || !res.success || res.error) { // Show correct answer if wrong or specific item error
                            resultHTML += `<p><span class="label">正確答案:</span> <span class="correct-answer-text">${correct}</span></p>`;
                         }

                         // Add specific item-level error if present (e.g., "[無法識別]")
                         if (res.error) {
                             resultHTML += `<p style="color: magenta; font-size: 0.9em;">項目提示: ${escapeHtml(res.error)}</p>`;
                         }
                        resultHTML += `</div>`; // Close result-item
                    });
                } else {
                     resultHTML += `<p>無法解析詳細評分結果。</p>`;
                     console.warn("Received result data missing 'results' array:", resultData);
                }

                // Display Overall Feedback (Scolding/Praise)
                if (resultData.feedback) {
                     const feedbackClass = (resultData.totalScore === 8) ? 'feedback-success' : 'feedback-fail';
                      // Use <pre> to respect newlines from AI feedback, apply escapeHtml for safety
                     resultHTML += `<div class="feedback-box ${feedbackClass}"><pre>${escapeHtml(resultData.feedback)}</pre></div>`;
                } else {
                     // Basic fallback feedback if backend didn't provide one
                     const basicFeedback = (resultData.totalScore === 8)
                         ? "滿分！表現不錯！"
                         : `總分 ${resultData.totalScore}！未達滿分，需要加強！`;
                    const fallbackClass = (resultData.totalScore === 8) ? 'feedback-success' : 'feedback-fail';
                     resultHTML += `<div class="feedback-box ${fallbackClass}"><p>${escapeHtml(basicFeedback)}</p></div>`;
                }

                resultDiv.innerHTML = resultHTML;

            } catch (error) {
                 console.error('提交答案或處理結果時出錯:', error);
                 // Display error within the result div
                 displayError(`提交或處理失敗: ${error.message}`, resultDiv);
            } finally {
                isSubmitting = false;
                setLoadingState(submitBtn, false, '提交答案照片');
                 // Re-enable start button to allow another try
                 setLoadingState(getQuestionBtn, false, '開始挑戰');
            }
        });

        // --- Initial Setup ---
        resetUI(); // Ensure clean state on load

    </script>
</body>
</html>