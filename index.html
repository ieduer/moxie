<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI é»˜å¯«</title>
    <style>
        /* Styles remain largely the same, no changes needed */
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; background-color: #f9f9f9; }
        h1 { text-align: center; color: #333; }
        strong { color: #d9534f; }
        #status, #questions, #result, #upload-section { margin-top: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 8px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .question-item { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed #eee; }
        .question-item:last-child { border-bottom: none; }
        /* Adjusted styling for moni.json format */
        .question-text { display: block; margin-bottom: 5px; font-weight: bold; } /* The main question text */

        pre { background-color: #f4f4f4; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; color: #333; border: 1px solid #ddd;}
        button { padding: 12px 20px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; font-size: 1em; transition: background-color 0.2s ease, transform 0.1s ease; margin: 5px; }
        button:active:not(:disabled) { transform: scale(0.98); } /* Add press effect */
        button:hover:not(:disabled) { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; }
        .button-group { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; justify-content: center; }
        h2 { margin-top: 0; color: #0056b3; border-bottom: 2px solid #eee; padding-bottom: 5px;}
        /* Underline style for blanks in question text (if any) */
        .underline-blank {
            text-decoration: none;
            border-bottom: 1.5px solid #888;
            padding: 0 0.5em;
            color: #888;
            display: inline-block;
            min-width: 6em; /* Adjusted slightly */
            text-align: center;
            font-weight: normal;
         }
        .loading { font-style: italic; color: #555; text-align: center; padding: 20px; font-size: 1.1em; }
        .result-item { margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; border-left-width: 5px; border-left-style: solid;} /* Combined border */
        .result-item p { margin: 8px 0; }
        .result-item strong { color: #333; }
        .result-item .label { font-weight: bold; color: #555; min-width: 70px; display: inline-block;}
        .recognized-text { font-weight: bold; padding: 2px 4px; border-radius: 3px; }
        .correct-answer-text { font-weight: bold; color: #1a7431; background-color: #e8f5e9; padding: 2px 4px; border-radius: 3px;}
        .incorrect-answer-text { color: #c62828; background-color: #ffebee; } /* Applied when recognized != correct */
        .unrecognized-text { color: #757575; background-color: #f5f5f5; font-style: italic; } /* For [ç„¡æ³•è­˜åˆ¥] etc */
        .correct-tick { color: green; font-weight: bold; margin-left: 5px; }
        .incorrect-cross { color: red; font-weight: bold; margin-left: 5px; }
        .error-message { color: #d9534f; font-weight: bold; margin-top: 10px; padding: 10px; background-color: #f2dede; border: 1px solid #ebccd1; border-radius: 4px;}
        .feedback-box { margin-top: 25px; padding: 15px; border-radius: 5px; font-size: 1.1em; text-align: center; white-space: pre-wrap; word-wrap: break-word; border: 1px solid; }
        /* Feedback Styles (Requirement 3 & 5) */
        .feedback-success { background-color: #dff0d8; border-color: #d6e9c6; color: #3c763d; font-weight: bold; }
        .feedback-fail { background-color: #f2dede; border-color: #ebccd1; color: #a94442; font-weight: bold; font-size: 1.2em; /* Make scolding more prominent */ }

        /* Styles for file upload and preview */
        #upload-section { border-top: 2px solid #007bff; margin-top: 30px; }
        #image-upload-label { display: block; margin-bottom: 10px; font-weight: bold; }
        #image-upload { display: block; margin-bottom: 15px; font-size: 1em; cursor: pointer; }
        #image-preview-container { margin-top: 15px; text-align: center; }
        #image-preview { max-width: 90%; max-height: 400px; border: 1px solid #ddd; border-radius: 4px; display: none; margin: 10px auto; box-shadow: 0 0 5px rgba(0,0,0,0.1); }
        #compression-info { font-size: 0.9em; color: #666; margin-top: 10px; text-align: center; min-height: 1.2em; }
        #submit-btn { margin-top: 20px; width: calc(100% - 10px); }

        /* Style for processing hints */
        .processing-hints {
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ffeeba;
            background-color: #fff3cd;
            color: #856404;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .processing-hints p { margin: 5px 0; font-weight: bold; }
        .item-hint { color: magenta; font-size: 0.9em; margin-top: 5px; font-style: italic; } /* For item-specific errors like [ç„¡æ³•è­˜åˆ¥] */

        /* --- Praise Animation --- (Requirement 6) */
        @keyframes celebrate {
            0% { transform: scale(1); background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
            50% { transform: scale(1.05); background-color: #dff0d8; box-shadow: 0 8px 16px rgba(60, 118, 61, 0.4); }
            100% { transform: scale(1); background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        }
        .full-marks-celebration {
            animation: celebrate 1.5s ease-in-out;
            border-color: #28a745 !important; /* Ensure border changes */
        }

    </style>
    <!-- **å¼•å…¥ browser-image-compression åº«** -->
    <!-- ä½¿ç”¨ BootCDN -->
<script src="https://cdn.bootcdn.net/ajax/libs/browser-image-compression/2.0.2/browser-image-compression.js"></script>
</head>
<body>
    <h1>AI é»˜å¯« <span style="font-size: 0.7em; color: #777;"></span></h1>
    <p style="text-align: center;"><strong>é«˜è€ƒé»˜å¯«8åˆ†ï¼Œæ”¾æ¢ç‹—éƒ½èƒ½æ‹¿æ»¿ï¼ä½•æ³æ˜¯ä½ æˆ‘ï¼</strong></p>
    <p style="text-align: center; color: orange; font-weight: bold;">
        4é“é¡Œï¼ŒæŒ‰é †åºåˆ†å››è¡Œï¼Œæ‹ç…§ä¸Šå‚³ã€‚ç¢ºä¿å­—è·¡æ¸…æ™°ï¼
    </p>

    <div class="button-group">
        <button id="get-question-btn">é–‹å§‹æŒ‘æˆ°</button>
    </div>

    <div id="status">ç‹€æ…‹ï¼šğŸ¶æ±ªæ±ªæ±ª...</div>

    <div id="questions" style="display: none;">
        <h2>ç­†å¢¨ä¼ºå€™ (å…± 8 åˆ†)</h2>
        <p style="text-align: center; color: #777; font-style: italic;">
            <strong style="color: red;">â€¼ï¸ï¼šè«‹å‹¿æ›¸å¯«é¡Œè™Ÿï¼Œç­”æ¡ˆä¸­**ä¸è¦åŠ æ¨™é»ç¬¦è™Ÿ**ã€‚â€¼ï¸ </strong>  
        </p>
        <div id="question-list"></div>
    </div>

    <div id="upload-section" style="display: none;">
        <h2>æ‹ç…§ä¸Šå‚³</h2>
        <label for="image-upload" id="image-upload-label">é¸æ“‡æˆ–æ‹æ”ç…§ç‰‡:</label>
        <input type="file" id="image-upload" name="image-upload" accept="image/*">  <!-- Requirement 1: Removed capture="environment" -->
        <div id="compression-info"></div>
        <div id="image-preview-container">
            <img id="image-preview" src="#" alt="åœ–ç‰‡é è¦½">
        </div>
         <button id="submit-btn" disabled>æå€‹äº¤</button>
    </div>

    <div id="result" style="display: none;"></div>

    <script>
        // --- DOM Elements ---
        const statusDiv = document.getElementById('status');
        const questionsDiv = document.getElementById('questions');
        const questionListDiv = document.getElementById('question-list');
        const uploadSection = document.getElementById('upload-section');
        const imageUploadInput = document.getElementById('image-upload');
        const imagePreview = document.getElementById('image-preview');
        const compressionInfo = document.getElementById('compression-info');
        const resultDiv = document.getElementById('result');
        const getQuestionBtn = document.getElementById('get-question-btn');
        const checkBackendBtn = document.getElementById('check-backend-btn');
        const submitBtn = document.getElementById('submit-btn');

        // --- State Variables ---
        let currentQuestions = [];
        let currentSetId = null;
        let compressedImageBlob = null;
        let isSubmitting = false;

        // --- Utility Functions ---
        function setLoadingState(button, isLoading, defaultText = 'æ“ä½œ') {
             button.disabled = isLoading;
             button.textContent = isLoading ? 'è™•ç†ä¸­...' : defaultText;
             // Add/remove loading class if needed for styling
             if (isLoading) {
                button.classList.add('loading-active'); // Add a class if you want specific loading styles
             } else {
                button.classList.remove('loading-active');
             }
        }

        function resetUI() {
            statusDiv.textContent = 'ç‹€æ…‹ï¼šç­‰å¾…æ“ä½œ...';
            resultDiv.style.display = 'none';
            resultDiv.innerHTML = '';
            resultDiv.classList.remove('full-marks-celebration'); // Ensure animation class is removed
            questionsDiv.style.display = 'none';
            uploadSection.style.display = 'none';
            questionListDiv.innerHTML = '';
            currentQuestions = [];
            currentSetId = null;
            compressedImageBlob = null;
            imagePreview.style.display = 'none';
            imagePreview.src = '#';
            imageUploadInput.value = '';
            compressionInfo.textContent = '';
            submitBtn.disabled = true;
            isSubmitting = false;
            setLoadingState(getQuestionBtn, false, 'é–‹æˆ°ï¼'); // Re-enable start button
            setLoadingState(submitBtn, false, 'æäº¤ç…§ç‰‡'); // Ensure submit is reset
            setLoadingState(checkBackendBtn, false, 'å¾Œç«¯ç‹€æ…‹'); // Ensure check button is reset
        }

        function displayError(message, container = statusDiv) {
             console.error("Error:", message);
             // Sanitize message before inserting as HTML
             const safeMessage = escapeHtml(message);
             container.innerHTML = `<div class="error-message">éŒ¯èª¤ï¼š${safeMessage}</div>`;
             container.style.display = 'block';
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') {
                 console.warn("escapeHtml called with non-string:", unsafe);
                 return String(unsafe); // Convert non-strings to strings
            }
            return unsafe
                 .replace(/&/g, "&")
                 .replace(/</g, "<")
                 .replace(/>/g, ">")
                 .replace(/"/g, '"')
                 .replace(/'/g, "'");
         }

        // --- Event Listeners ---

        getQuestionBtn.addEventListener('click', async () => {
            resetUI();
            setLoadingState(getQuestionBtn, true, 'é–‹æˆ°');
            statusDiv.textContent = 'æ­£åœ¨ç²å–æ–°é¡Œçµ„...';
            statusDiv.style.display = 'block'; // Show status

            try {
                const response = await fetch('/api/start_set');
                 if (!response.ok) {
                     let errorMsg = `HTTP éŒ¯èª¤ï¼ç‹€æ…‹: ${response.status}`;
                     try {
                         const errorData = await response.json();
                         errorMsg = errorData.error || errorMsg;
                     } catch (e) { /* Ignore */ }
                     throw new Error(errorMsg);
                 }

                const setData = await response.json();

                if (setData && setData.setId && setData.questions && setData.questions.length > 0) {
                    currentSetId = setData.setId;
                    currentQuestions = setData.questions;

                    statusDiv.textContent = `ç²å–é¡Œçµ„æˆåŠŸ (ID: ${currentSetId.substring(0, 8)}...)ï¼è«‹ä½œç­”å¾Œæ‹ç…§ä¸Šå‚³ã€‚`;
                    questionsDiv.style.display = 'block';
                    uploadSection.style.display = 'block';

                    // Display questions from moni.json structure (Requirement 2: Removed question numbers)
                    questionListDiv.innerHTML = ''; // Clear previous list
                    currentQuestions.forEach((q, index) => { // index parameter kept but not used
                        const item = document.createElement('div');
                        item.classList.add('question-item');

                        // Format the question text, replacing blanks if needed
                        const formattedQuestion = escapeHtml(q.question || "").replace(/_{2,}/g, '<span class="underline-blank">Â </span>');

                        // Prepare details string (Topic & Source)
                        const topicText = escapeHtml(q.topic || "æœªçŸ¥ä¸»é¡Œ");
                        const sourceText = escapeHtml(q.source || "æœªçŸ¥é¡å‹");
                        const detailsString = `(${topicText} | é¡å‹: ${sourceText})`;

                        item.innerHTML = `
                            <p>
                                <span class="question-text">${formattedQuestion}</span>
                             </p>`;
                        questionListDiv.appendChild(item);
                    });

                    // Scroll to questions
                    questionsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });

                } else {
                    throw new Error('æœªèƒ½å¾å¾Œç«¯ç²å–æœ‰æ•ˆçš„é¡Œçµ„æ•¸æ“šã€‚è¿”å›æ•¸æ“šçµæ§‹å¯èƒ½ä¸æ­£ç¢ºã€‚');
                }
            } catch (error) {
                displayError(`ç²å–é¡Œç›®å¤±æ•—: ${error.message}`);
                resetUI(); // Reset UI fully on error
            } finally {
                setLoadingState(getQuestionBtn, false, 'é–‹æˆ°');
            }
        });

        imageUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            compressedImageBlob = null;
            submitBtn.disabled = true;
            imagePreview.style.display = 'none';
            compressionInfo.textContent = '';
            // Clear previous errors shown in compressionInfo
            if (compressionInfo.querySelector('.error-message')) {
                compressionInfo.innerHTML = '';
            }


            if (!file) return;

            if (!file.type.startsWith('image/')) {
                displayError('è«‹é¸æ“‡æœ‰æ•ˆçš„åœ–ç‰‡æ–‡ä»¶ï¼', compressionInfo);
                imageUploadInput.value = '';
                return;
            }

            // Show Preview
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
            }
            reader.readAsDataURL(file);

            // Compress Image
            compressionInfo.textContent = 'æ­£åœ¨å£“ç¸®åœ–ç‰‡...';
            console.log(`åŸå§‹åœ–ç‰‡å¤§å°: ${(file.size / 1024 / 1024).toFixed(2)} MB`);

            const options = {
                maxSizeMB: 1.5, // Slightly increased max size if needed
                maxWidthOrHeight: 1920,
                useWebWorker: true,
                // initialQuality: 0.7 // You can adjust initial quality
            };

            try {
                compressedImageBlob = await imageCompression(file, options);
                console.log(`å£“ç¸®å¾Œåœ–ç‰‡å¤§å°: ${(compressedImageBlob.size / 1024 / 1024).toFixed(2)} MB`);
                compressionInfo.textContent = `åœ–ç‰‡å·²æº–å‚™å°±ç·’ (å¤§å°: ${(compressedImageBlob.size / 1024 / 1024).toFixed(2)} MB)`;
                submitBtn.disabled = false; // Enable submit
            } catch (error) {
                console.error('åœ–ç‰‡å£“ç¸®å¤±æ•—:', error);
                displayError(`åœ–ç‰‡å£“ç¸®å¤±æ•—: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}`, compressionInfo);
                compressedImageBlob = null;
                imagePreview.style.display = 'none';
                imageUploadInput.value = '';
            }
        });

        checkBackendBtn.addEventListener('click', async () => {
             setLoadingState(checkBackendBtn, true, 'æª¢æŸ¥å¾Œç«¯ç‹€æ…‹');
             statusDiv.textContent = 'æ­£åœ¨æª¢æŸ¥å¾Œç«¯ç‹€æ…‹...';
             statusDiv.style.display = 'block';
             try {
                 const response = await fetch('/api/hello');
                 if (!response.ok) throw new Error(`HTTP ${response.status} ${response.statusText}`);
                 const data = await response.json();
                 // Use pre for better formatting, escape the JSON string
                 statusDiv.innerHTML = `å¾Œç«¯ç‹€æ…‹ï¼š<pre>${escapeHtml(JSON.stringify(data, null, 2))}</pre>`;
             } catch (error) {
                 displayError(`ç„¡æ³•é€£æ¥å¾Œç«¯æˆ–å¾Œç«¯éŒ¯èª¤: ${error.message}`);
             } finally {
                 setLoadingState(checkBackendBtn, false, 'æª¢æŸ¥å¾Œç«¯ç‹€æ…‹');
             }
        });

        submitBtn.addEventListener('click', async () => {
            if (isSubmitting) return;
            if (!compressedImageBlob) {
                alert('éŒ¯èª¤ï¼šæ²’æœ‰æº–å‚™å¥½çš„åœ–ç‰‡æ•¸æ“šã€‚è«‹å…ˆé¸æ“‡ä¸¦ç­‰å¾…åœ–ç‰‡å£“ç¸®å®Œæˆï¼');
                return;
            }
            if (!currentSetId) {
                 alert('éŒ¯èª¤ï¼šç¼ºå°‘é¡Œçµ„ä¿¡æ¯ (Set ID)ã€‚è«‹å…ˆé»æ“Š "é–‹å§‹æŒ‘æˆ°" ç²å–é¡Œç›®ã€‚');
                 return;
            }

            isSubmitting = true;
            setLoadingState(submitBtn, true, 'æäº¤ç­”æ¡ˆç…§ç‰‡');
            resultDiv.innerHTML = '<div class="loading">æ­£åœ¨ä¸Šå‚³åœ–ç‰‡ä¸¦ç­‰å¾… AI è©•åˆ†ï¼Œéœ€è¦ä¸€äº›æ™‚é–“ï¼Œè«‹è€å¿ƒç­‰å¾…...</div>';
            resultDiv.style.display = 'block';
            resultDiv.scrollIntoView({ behavior: 'smooth' });

            const formData = new FormData();
            formData.append('setId', currentSetId);
            // Generate a unique filename including timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `set_${currentSetId.substring(0, 8)}_${timestamp}.png`;
            formData.append('handwritingImage', compressedImageBlob, filename);


            try {
                const response = await fetch('/api/submit', {
                    method: 'POST',
                    body: formData,
                });

                 if (!response.ok) {
                     let errorMsg = `æäº¤å¤±æ•—ï¼ç‹€æ…‹: ${response.status}`;
                     try {
                         const errorData = await response.json();
                         errorMsg = errorData.error || errorMsg;
                     } catch (e) { /* Ignore */ }
                     throw new Error(errorMsg);
                 }

                const resultData = await response.json();
                console.log("Result Data Received:", resultData); // Log received data

                // --- Render Results ---
                let resultHTML = `<h2>è©•åˆ†çµæœ (ç¸½åˆ†: ${resultData.totalScore ?? 'N/A'} / 8)</h2>`;

                 // Display General Processing Hints (OCR/Feedback API Issues)
                 let hintsHTML = '';
                 if (resultData.ocrIssue) {
                     hintsHTML += `<p>åœ–ç‰‡è­˜åˆ¥æç¤ºï¼š${escapeHtml(resultData.ocrIssue)}</p>`;
                 }
                 if (hintsHTML) {
                    resultHTML += `<div class="processing-hints">${hintsHTML}</div>`;
                 }

                // Display Individual Question Results
                if (resultData.results && Array.isArray(resultData.results)) {
                    resultData.results.forEach((res, index) => {
                        const isCorrect = res.isCorrect;
                        const score = res.score !== undefined ? res.score.toFixed(1) : 'N/A'; // Format score
                        const recognized = escapeHtml(res.recognizedText || '[æœªèƒ½è­˜åˆ¥]');
                        const correct = escapeHtml(res.correctAnswer || '[æ¨™æº–ç­”æ¡ˆç¼ºå¤±]');

                        let borderColor = '#ccc'; // Default border
                        let recognizedClass = ''; // Class for recognized text span
                        let tickOrCross = '';

                        if (res.success === false || recognized.startsWith('[')) {
                            borderColor = '#aaa'; // Grey for processing errors/unrecognized
                            recognizedClass = 'unrecognized-text';
                            tickOrCross = `<span class="incorrect-cross">âœ˜</span> <span style="color: #aaa;">(è™•ç†å¤±æ•—)</span>`;
                        } else if (isCorrect) {
                            borderColor = '#5cb85c'; // Green for correct
                            recognizedClass = ''; // Default styling
                            tickOrCross = '<span class="correct-tick">âœ”</span>';
                        } else {
                            borderColor = '#d9534f'; // Red for incorrect
                            recognizedClass = 'incorrect-answer-text'; // Add red background class
                            tickOrCross = '<span class="incorrect-cross">âœ˜</span>';
                        }

                        resultHTML += `<div class="result-item" style="border-left-color: ${borderColor};">`;
                        resultHTML += `<p><strong>ç¬¬ ${index + 1} é¡Œ</strong> (å¾—åˆ†: ${score}) ${tickOrCross}</p>`;

                         // Display recognized and correct answers
                         resultHTML += `<p><span class="label">è­˜åˆ¥çµæœ:</span> <span class="recognized-text ${recognizedClass}">${recognized}</span></p>`;
                         // Always show correct answer if not correct, or if there was an item-level error
                         if (!isCorrect || !res.success || res.error) {
                            resultHTML += `<p><span class="label">æ­£ç¢ºç­”æ¡ˆ:</span> <span class="correct-answer-text">${correct}</span></p>`;
                         }

                         // Add specific item-level error hint (e.g., "AI ç„¡æ³•è­˜åˆ¥æ­¤ç­”æ¡ˆ")
                         if (res.error) {
                             resultHTML += `<p class="item-hint">æç¤º: ${escapeHtml(res.error)}</p>`;
                         }
                        resultHTML += `</div>`; // Close result-item
                    });
                } else {
                     resultHTML += `<p class="error-message">ç„¡æ³•è§£æè©³ç´°è©•åˆ†çµæœã€‚æ”¶åˆ°çš„æ•¸æ“šæ ¼å¼å¯èƒ½æœ‰èª¤ã€‚</p>`;
                     console.warn("Received result data missing or invalid 'results' array:", resultData);
                }

                // Display Overall Feedback (Scolding/Praise) + Animation
                 resultDiv.innerHTML = resultHTML; // Render results first

                 // Add feedback box after results are rendered
                 const feedbackContainer = document.createElement('div');
                 if (resultData.feedback) {
                     const isFullMarks = (resultData.totalScore === 8);
                     const feedbackClass = isFullMarks ? 'feedback-success' : 'feedback-fail';
                     // Use <pre> to respect newlines, escape content
                     feedbackContainer.className = `feedback-box ${feedbackClass}`;
                     const pre = document.createElement('pre');
                     pre.textContent = resultData.feedback; // Use textContent for auto-escaping by browser
                     feedbackContainer.appendChild(pre);

                     // (Requirement 6) Trigger animation AFTER rendering results+feedback
                     if (isFullMarks) {
                         // Apply animation class to the main result div
                         resultDiv.classList.add('full-marks-celebration');
                         // Optional: Remove class after animation completes
                         setTimeout(() => {
                             resultDiv.classList.remove('full-marks-celebration');
                         }, 1500); // Match animation duration
                     }

                 } else {
                     // Basic fallback feedback if backend didn't provide one
                     const isFullMarks = (resultData.totalScore === 8);
                     const basicFeedback = isFullMarks
                         ? "æ»¿åˆ†ï¼è¡¨ç¾ä¸éŒ¯ï¼"
                         : `ç¸½åˆ† ${resultData.totalScore ?? 'N/A'}ï¼æœªé”æ»¿åˆ†ï¼Œé‚„éœ€åŠªåŠ›ï¼é€™æ¬¡é¥’äº†ä½ ï¼Œä¸‹æ¬¡æ³¨æ„ï¼`; // Slightly less harsh fallback
                    const fallbackClass = isFullMarks ? 'feedback-success' : 'feedback-fail';
                    feedbackContainer.className = `feedback-box ${fallbackClass}`;
                    feedbackContainer.innerHTML = `<p>${escapeHtml(basicFeedback)}</p>`; // Escape basic feedback too
                 }
                 resultDiv.appendChild(feedbackContainer); // Add feedback box to the results div

                 // --- (Requirement 6) Display Rank and Badge ---
                 if (resultData.badge) {
                     resultHTML += `<div style="text-align: center; margin-top: 20px; font-size: 1.2em; font-weight: bold; color: #007bff;">æ­å–œä½ ç²å¾— <span style="font-size: 1.5em;">${resultData.badge}</span> å¾½ç« ï¼ï¼ˆå¿ƒè£¡æœ‰å°±å¥½ï¼‰</div>`;
                 }
                 if (resultData.rank !== undefined) {
                     resultHTML += `<div style="text-align: center; margin-bottom: 10px; font-size: 0.9em; color: #777;">ç•¶å‰æ®µä½ï¼š${convertToChineseRankFrontend(resultData.rank)}éš</div>`;
                 }
                 resultDiv.innerHTML = resultHTML; // Re-render with rank and badge
                 resultDiv.appendChild(feedbackContainer); // Ensure feedback is still there after re-render


            } catch (error) {
                 console.error('æäº¤ç­”æ¡ˆæˆ–è™•ç†çµæœæ™‚å‡ºéŒ¯:', error);
                 displayError(`æäº¤æˆ–è™•ç†å¤±æ•—: ${error.message}`, resultDiv);
            } finally {
                isSubmitting = false;
                setLoadingState(submitBtn, false, 'æäº¤ç­”æ¡ˆç…§ç‰‡');
                // Don't automatically re-enable start button, let user decide
                // setLoadingState(getQuestionBtn, false, 'é–‹å§‹æŒ‘æˆ°');
            }
        });

        // --- Initial Setup ---
        resetUI();

        // --- (Requirement 6) Frontend Helper function for Chinese Rank (same as backend) ---
        function convertToChineseRankFrontend(rank) {
            const chineseNumbers = ["é›¶", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹", "å"];
            if (rank <= 10) {
                return chineseNumbers[rank];
            } else if (rank < 20) {
                return "å" + chineseNumbers[rank - 10];
            } else if (rank % 10 === 0) {
                return chineseNumbers[Math.floor(rank / 10)] + "å";
            } else {
                return chineseNumbers[Math.floor(rank / 10)] + "å" + chineseNumbers[rank % 10];
            }
        }
    </script>
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "qz8lnht4jz");
    </script>
  <footer>
    <p>Â©Suen <a href="https://bdfz.net/posts/moxie" target="_blank" rel="noopener noreferrer">About</a></p>
  </footer>
</body>
</html>